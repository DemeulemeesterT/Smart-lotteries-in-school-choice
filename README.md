This code accompanies the paper 'Smart Lotteries in School Choice: Ex-Ante Improvement with Ex-Post Stability' by Haris Aziz, Gergely Csáji, Péter Biró, and Tom Demeulemeester.

Consider a typical school choice setting where students have strict preferences and the schools have weak priorities, because they are indifferent between certain sets of students. This code can be used to compute random matchings that are ex-post stable (i.e., can be decomposed over a lottery of weakly stable matchings) that sd-improve upon a given random matching.

To run the simulations, fill in the following parameters:

**Main parameters**
* `n_students_schools`: vector containing pairs with number of students and schools. E.g., `[[40,8],[80,16]]` will first run `n_iterations_simul` instances with 40 students and 8 schools, and then the same number with 80 students and 16 schools
* `compare_solutions`: Choose which solutions you evaluate. All possible options are:
    * `SD_UPON_DA`: sd-improve upon DA with random tie-breaking, using the matchings generated by Stable Improvement Cycles (SICs) of Erdil & Ergin
    * `SD_UPON_EE`: Same, but sd-improving upon the solution of Erdil & Erdin (running SICs for each matching found by DA with tie-breaking)
    * `SD_UPON_EADA`: sd-improve upon EADA
    * `SD_UPON_DA_SAMPLE`: generate `n_sol_extra_sample` additional weakly stable matchings (by running DA with random tie-breaking + SICs), and then sd-improve upon DA.
    * `SD_UPON_EE_SAMPLE`: generate `n_sol_extra_sample` additional weakly stable matchings (by running DA with random tie-breaking + SICs), and then sd-improve upon EE.
    * `SD_UPON_EADA_SAMPLE`: generate `n_sol_extra_sample` additional weakly stable matchings (by running DA with random tie-breaking + SICs), and then sd-improve upon EADA.
* `n_iterations_simul`: number of instances evaluated for each pair of (number of students, number of schools)

**Detailed parameters**
* `bool_ColumnGen`: boolean to determine whether or not to run column generation (True: run column generation, False: don't run)
* `bool_supercolumn`: boolean to determine whether you want to add an artificial column to the model when the model is infeasible?
* `bool_identical_students`: boolean to determine whether identical students are given identical probabilities. (Note: difference between probabilities is determined in `ModulColumnGen.py` (lines 179, 181))

* `n_match`: Number of matchings used to estimate DA (e.g., 1000)
* `time_lim`: time limit for the column generation framework (in seconds)
* `n_sol_extra_example`: Number of extra solutions added to solution pool for sampling methods

* `n_sol_pricing`: Number of solutions added to main problem by each iteration of the pricing problem
* `n_sol_pricingMinRank`: Number of solutions found by pricing that minimizes average rank
* `gap_solutionpool_pricing`: Optimality gap for solutions that are added to main problem by the pricing problem
* `MIPGap`: Initial optimality gap for main problem

* `seed`: seed pseudo-random number generator

* `alpha` and `beta`: parameters for data generation, see Erdil & Ergin (2008) for detailed explanation. Could be controled by setting `ALPHA_INCREMENT` and `BETA_INCREMENT` (to evaluate for range of values), or by simply add the desired values in the array

* `print_intermediate`: boolean to control which output is printed